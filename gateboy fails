*   lcdon_to_stat1_d.gb             133  132    1  255 FAIL @ 17599 // phase 140648. stat goes to 0 on the phase C _after_ the read
*   lcdon_to_stat2_a.gb             132  128    4  255 FAIL @ 157   // lyc match goes to 0 on the phase C _after_ the read

    poweron_006_stat.gb             133  132    1  255 FAIL @ 31    // stat 0 goes to 0 on the phase C _after_ the read
    poweron_120_stat.gb             132  128    4  255 FAIL @ 145


*   lcdon_to_oam_unlock_d.gb          0   39  -39  255 FAIL @ 109   // XYMU goes 0 on phase H during the read, but OAM is still locked until A. Race between H and A?
*   line_153_lyc0_int_inc_sled.gb    97   98   -1  255 FAIL @ 17491 // int firing on phase C before the last inc

*   oam_read_l0_d.gb                  0  240 -240  255 FAIL @ 101 // XYMU goes 0 on phase H during the read, but OAM is still locked until A. Race between H and A?
*   oam_read_l1_a.gb                240  255  -15  255 FAIL @ 151 // LATCH_EXT goes to 1 on phase E, but BESU_SCANNINGp doesn't go to 1 until A
*   oam_read_l1_f.gb                240  255  -15  255 FAIL @ 265 // LATCH_EXT goes to 1 on phase E, but BESU_SCANNINGp doesn't go to 1 until A
*   oam_write_l0_b.gb               145  240  -95  255 FAIL @ 107 // WR_A has a glitch to 0 in phase D, we should prob be using the oam clock...
*   oam_write_l0_d.gb               240  145   95  255 FAIL @ 110 // something w/ OAM_CLK, OAM_WR, etc. gliches in HA
*   oam_write_l1_c.gb               240  145   95  255 FAIL @ 228 // glitch gap between scanning and rendering

*   poweron_006_oam.gb                0  255 -255  255 FAIL @ 31
    poweron_120_oam.gb                0  255 -255  255 FAIL @ 145
    poweron_234_oam.gb                0  255 -255  255 FAIL @ 259

*   poweron_026_vram.gb               0  255 -255  255 FAIL @ 51
    poweron_140_vram.gb               0  255 -255  255 FAIL @ 165

*   ppu_sprite0_scx3_a.gb           128  131   -3  255 FAIL @ 234 // this one looks actually broken, stat goes 0 a full cycle before the read
*   ppu_sprite0_scx7_a.gb           128  131   -3  255 FAIL @ 234 // stat changes 0 on same phase B as read addr goes on the bus

*   stat_write_glitch_l0_a.gb       224  226   -2  255 FAIL @ 51
*   stat_write_glitch_l0_b.gb       224  226   -2  255 FAIL @ 160
*   stat_write_glitch_l1_b.gb       224  226   -2  255 FAIL @ 224
*   stat_write_glitch_l1_c.gb       224  226   -2  255 FAIL @ 274






m3_bgp_change.gb - fail, check lcd interface
m3_bgp_change_sprites.gb - looks correct
m3_lcdc_bg_en_change.gb - looks correct
m3_lcdc_bg_map_change.gb - looks correct
m3_lcdc_obj_en_change.gb - might be off by one pixel
m3_lcdc_obj_en_change_variant.gb - off by one pixel again
m3_lcdc_obj_size_change.gb - fail!?!
m3_lcdc_obj_size_change_scx.gb - fail!?!
m3_lcdc_tile_sel_change.gb - looks ok
m3_lcdc_tile_sel_win_change.gb - looks ok
m3_lcdc_win_en_change_multiple.gb - looks ok
m3_lcdc_win_en_change_multiple_wx.gb - looks ok, even the glitchy dots
m3_lcdc_win_map_change.gb - looks ok
m3_obp0_change.gb - close but no cigar
m3_scx_low_3_bits.gb - looks ok
m3_window_timing.gb - looks ok
m3_window_timing_wx_0.gb - looks ok
m3_wx_4_change.gb - looks ok
m3_wx_4_change_sprites.gb - looks ok
m3_wx_5_change.gb - looks ok
m3_wx_6_change.gb - looks ok